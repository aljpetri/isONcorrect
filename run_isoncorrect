#! /usr/bin/env python

from __future__ import print_function
import os,sys
import argparse
from sys import stdout
import shutil
import subprocess

import errno
from time import time
import itertools

import signal
from multiprocessing import Pool
import multiprocessing as mp

# import math
import re

def mkdir_p(path):
    try:
        os.makedirs(path)
        print("creating", path)
    except OSError as exc:  # Python >2.5
        if exc.errno == errno.EEXIST and os.path.isdir(path):
            pass
        else:
            raise


def isoncorrect(data):
    isoncorrect_location, read_fastq_file, outfolder, cl_id = data[0],data[1],data[2], data[3]
    mkdir_p(outfolder)
    isoncorrect_exec = os.path.join(isoncorrect_location, "isONcorrect3")
    isoncorrect_error_file = os.path.join(outfolder, "stderr.txt")
    with open(isoncorrect_error_file, "w") as error_file:
        print('Running isoncorrect cl_id:{0}...'.format(cl_id), end=' ')
        stdout.flush()
        
        # null = open("/dev/null", "w")
        isoncorrect_out_file = open(os.path.join(outfolder, "stdout.txt"), "w")
        subprocess.check_call([ isoncorrect_exec, "--fastq",  read_fastq_file,  "--outfolder",  outfolder ], stderr=error_file, stdout=isoncorrect_out_file)
        print('Done.')
        stdout.flush()
    error_file.close()
    isoncorrect_out_file.close()
    return

def main(args):
    directory = os.fsencode(args.fastq_folder)
    isoncorrect_location = os.path.dirname(os.path.realpath(__file__))
    print(isoncorrect_location)
    instances = []
    for file_ in os.listdir(directory):
        read_fastq_file = os.fsdecode(file_)
        if read_fastq_file.endswith(".fastq"): 
            cl_id = read_fastq_file.split(".")[0]
            outfolder = os.path.join(args.outfolder, cl_id)
            # print(cl_id, outfolder, read_fastq_file, directory)
            fastq_file_path = os.path.join(os.fsdecode(directory), read_fastq_file)
            # print(fastq_file_path)
            instances.append((isoncorrect_location, fastq_file_path, outfolder, int(cl_id)) )
            # print(os.path.join(directory, read_fastq_file))
            continue
        else:
            continue

    # sys.exit()
    instances.sort(key = lambda x: x[3])
    for t in instances:
        print(t)
    original_sigint_handler = signal.signal(signal.SIGINT, signal.SIG_IGN)
    signal.signal(signal.SIGINT, original_sigint_handler)
    mp.set_start_method('spawn')
    print(mp.get_context())
    print("Environment set:", mp.get_context())
    print("Using {0} cores.".format(args.nr_cores))
    start_multi = time()
    pool = Pool(processes=int(args.nr_cores))
    try:
        res = pool.map_async(isoncorrect, instances, chunksize=1)
        score_results =res.get(999999999) # Without the timeout this blocking call ignores all signals.
    except KeyboardInterrupt:
        print("Caught KeyboardInterrupt, terminating workers")
        pool.terminate()
        sys.exit()
    else:
        pool.close()
    pool.join()

    print("Time elapesd multiprocessing:", time() - start_multi)


    return


if __name__ == '__main__':
    parser = argparse.ArgumentParser(description="De novo clustering of long-read transcriptome reads", formatter_class=argparse.ArgumentDefaultsHelpFormatter)
    parser.add_argument('--version', action='version', version='%(prog)s 0.0.2')
    parser.add_argument('--fastq_folder', type=str,  default=False, help='Path to input fastq folder with reads in clusters')
    parser.add_argument('--t', dest="nr_cores", type=int, default=8, help='Number of cores allocated for clustering')
    parser.add_argument('--k', type=int, default=7, help='Kmer size')
    parser.add_argument('--w', type=int, default=10, help='Window size')
    parser.add_argument('--xmin', type=int, default=14, help='Upper interval length')
    parser.add_argument('--xmax', type=int, default=80, help='Upper interval length')
    parser.add_argument('--T', type=float, default=0.2, help='Upper interval length')
    parser.add_argument('--exact', action="store_true", help='Get exact solution for WIS for evary read (recalculating weights for each read (much slower but slightly more accuracy,\
                                                                 not to be used for clusters with over ~500 reads)')
  
    parser.add_argument('--outfolder', type=str,  default=None, help='A fasta file with transcripts that are shared between samples and have perfect illumina support.')
    args = parser.parse_args()

    if len(sys.argv)==1:
        parser.print_help()
        sys.exit()
    
    if args.outfolder and not os.path.exists(args.outfolder):
        os.makedirs(args.outfolder)

    main(args)
